// Global uniforms from JME
uniform mat4 g_ProjectionMatrixInverse;
uniform mat4 g_ViewMatrix;
uniform vec2 g_Resolution;

// MRT Textures
uniform sampler2D m_NormalBuffer;
uniform sampler2D m_DiffuseBuffer;
uniform sampler2D m_DepthBuffer;

// Material
uniform vec3 m_FrustumCorner;
uniform vec2 m_FrustumNearFar;

struct DM_GBuffer{
	float depth;
	float linear_depth;
	float specular;
	vec3 normal;
	vec3 position;
	vec3 albedo;
} GBuffer;

float dm_depth(vec2 tc){
  return texture2D(m_DepthBuffer, tc).r;
}

vec3 dm_position(vec2 tc, float projectiveDepth){
  vec4 position = vec4(tc*2.0-1.0, projectiveDepth*2.0-1.0, 1.0);
  position = g_ProjectionMatrixInverse*position;
  return position.xyz/position.w;
}

vec3 dm_normal(vec2 tc){
  return normalize((texture2D(m_NormalBuffer, tc) * 2.0 - 1.0).rgb);
}

/**
 * Reconstructiong linear depth
 */
float dm_non_linear_2_linear_depth(float w){
	float wnear = m_FrustumNearFar.x;
	float wfar = m_FrustumNearFar.y;
	return (w - wnear) * (wfar / (wfar - wnear));
}

void dm_decode() {
	vec2 tc = gl_FragCoord.xy/g_Resolution;
	
	GBuffer.depth = dm_depth(tc);
	GBuffer.linear_depth = dm_non_linear_2_linear_depth(GBuffer.depth);
	
	// Decode normal and specular
	vec4 normalAndSpecluar = texture2D(m_NormalBuffer, tc);	
	GBuffer.normal = normalAndSpecluar.rgb * 2.0 - 1.0;
	GBuffer.specular = normalAndSpecluar.a;

	// Decode position
	GBuffer.position = dm_position(tc, GBuffer.depth);
	
	// Recover albedo
	GBuffer.albedo = texture2D(m_DiffuseBuffer, tc).rgb;
}

