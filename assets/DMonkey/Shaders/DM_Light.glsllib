#import "DMonkey/Shaders/GBuffer.glsllib"

const int QUALITY_LOW  = 0,
          QUALITY_MED  = 1,
          QUALITY_HIGH = 2;

const float PI = 3.14159265358979323846264;
const float ONE_OVER_PI = 1.0 / PI;
const float PI_OVER_FOUR = PI / 4.0;
const float PI_OVER_TWO = PI / 2.0;

// Use this instead of Lambert for the diffuse part
float OrenNayar(vec3 normal, vec3 lightDir, vec3 viewDir, float roughness)
{
    float vdotl = max(0.0, dot(viewDir, lightDir));
    float ndotv = max(0.0, dot(normal, viewDir));
    float ndotl = max(0.0, dot(normal, lightDir));

    // theta_o = arcsin ndotv (as angle)
    // theta_i = arcsin ndotl
    float sigma2 = roughness * roughness;
    float A = 1.0  - (0.5 * sigma2) / (sigma2 + 0.33);
    float B = (0.45 * sigma2) / (sigma2 + 0.09);
    float alpha = max(ndotl, ndotv);
    float beta  = min(ndotl, ndotv);
    return (ndotl * ONE_OVER_PI) * (A + B * vdotl * sin(alpha) * tan(beta));
}

float Lambert(vec3 normal, vec3 lightDir){
  return max(dot(normal, lightDir), 0.0);
}


vec3 gamma(vec3 color, float gamma){
  color.r = pow(color.r, gamma);
  color.g = pow(color.g, gamma);
  color.b = pow(color.b, gamma);
  return color;
}

struct Light {
	vec4 color;
	vec3 position;

	vec3 direction;
};

const float SHINY = 80.0;
const float R0 = 0.02037;
float fastFresnel(vec3 ViewDir, vec3 Normal){
  return R0 + (1.0 - R0)*pow((1.0 - dot(ViewDir, Normal)),5.0);
}
vec4 ComputeLighting(Light light) {
    float Roughness = 128.0;

    float lambert = Lambert(GBuffer.normal, light.direction);
    lambert = OrenNayar(GBuffer.normal, light.direction, normalize(GBuffer.position), mod(g_Time, 1.0));
    
    vec4 DiffuseColor  = vec4(0, 0, 0, 0);
    vec4 SpecularColor = vec4(0, 0, 0, 0);
    
    float specPower = pow(2.0, (10.0 * (Roughness / 255.0) + 1.0));

    
    	DiffuseColor = light.color * lambert;

	    #ifdef SPECULAR
		    vec3 vsCameraDir = normalize(GBuffer.position);
		    vec3 reflection = reflect(light.direction, GBuffer.normal);
		    float specular = max(dot(vsCameraDir, normalize(reflection)), 0.0);
		    specular = pow(specular, specPower);
		    if (specular > 0.0) {
            	SpecularColor = vec4(1.0) * GBuffer.specular * specular;
        	}
	    #else
	    	float specular = 0.0;
	    #endif
	

    return DiffuseColor + SpecularColor * 0.0;
}

// Other uses.. later on
void prepare() {
	// Do it here
	dm_decode();
}
